import BigNumber from 'bignumber.js';
import Web3 from 'web3';

import { assert } from '../assert';
import { schemas } from '../schemas/';
import { Utils } from './Utils';

// Types
import { Provider } from '@0xproject/types';
import { ECSignature, Order, SignedOrder } from '../types/Order';
import { MarketContract, OrderLib } from '@marketprotocol/types';

/**
 * Computes the orderHash for a supplied order.
 * @param   provider   Web3 provider instance.
 * @param   order      An object that confirms to the Order interface definitions.
 * @return  The resulting orderHash from hashing the supplied order.
 */
export async function createOrderHashAsync(
  provider: Provider,
  order: Order | SignedOrder
): Promise<string> {
  assert.isSchemaValid('Order', order, schemas.OrderSchema);

  const web3: Web3 = new Web3();
  web3.setProvider(provider);

  const orderLib: OrderLib = await OrderLib.createAndValidate(web3, order.contractAddress);

  let orderHash = '';

  await orderLib
    .createOrderHash(
      order.contractAddress,
      // orderAddresses
      [order.maker, order.taker, order.feeRecipient],
      // unsignedOrderValues
      [order.makerFee, order.takerFee, order.price, order.expirationTimestamp, order.salt],
      order.orderQty
    )
    .then(data => {
      orderHash = data.toString();
    })
    .catch(err => {
      console.log('Error while creating order hash');
      console.error(err);
    });

  return orderHash;
}

/**
 * Signs an orderHash and returns it's elliptic curve signature.
 * @param   provider        Web3 provider instance.
 * @param   orderHash       Hex encoded orderHash to sign.
 * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address
 *          must be available via the Provider supplied to MARKET.js.
 * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.
 */
export async function signOrderHashAsync(
  provider: Provider,
  orderHash: string,
  signerAddress: string
): Promise<ECSignature> {
  const web3: Web3 = new Web3();
  web3.setProvider(provider);

  const ecSignature: ECSignature = await Utils.signMessage(web3, signerAddress, orderHash);

  console.log(ecSignature);

  return ecSignature;
}

/**
 * Trades an order and returns success or error.
 * @param   provider        Web3 provider instance.
 * @param   signedOrder     An object that conforms to the SignedOrder interface. The
 *                          signedOrder you wish to validate.
 * @param   fillQty         The amount of the order that you wish to fill.
 * @return  A boolean indicating whether the order has been successfully traded or not.
 */
export async function tradeOrderAsync(
  provider: Provider,
  signedOrder: SignedOrder,
  fillQty: number
): Promise<boolean> {
  assert.isSchemaValid('SignedOrder', signedOrder, schemas.SignedOrderSchema);

  const web3: Web3 = new Web3();
  web3.setProvider(provider);

  const marketContract: MarketContract = new MarketContract(web3, signedOrder.contractAddress);

  const filledQty = await marketContract.tradeOrderTx(
    // orderAddresses
    [signedOrder.maker, signedOrder.taker, signedOrder.feeRecipient],
    // unsignedOrderValues
    [
      signedOrder.makerFee,
      signedOrder.takerFee,
      signedOrder.price,
      signedOrder.expirationTimestamp,
      signedOrder.salt
    ],
    signedOrder.orderQty,
    fillQty,
    signedOrder.ecSignature.v,
    new BigNumber(signedOrder.ecSignature.r),
    new BigNumber(signedOrder.ecSignature.s)
  );

  console.log(filledQty);

  return true;
}
