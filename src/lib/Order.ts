import BigNumber from 'bignumber.js';
import Web3 from 'web3';

// import { assert } from '../assert';
// import { schemas } from '../schemas/';
import { Utils } from './Utils';

// Types
import { Provider } from '@0xproject/types';
import { ECSignature, Order, SignedOrder } from '../types/Order';
import { ITxParams, MarketContract, OrderLib } from '@marketprotocol/types';

/**
 * Computes the orderHash for a supplied order.
 * @param   provider   Web3 provider instance.
 * @param   orderLibAddress address of the deployed OrderLib.sol
 * @param   order      An object that confirms to the Order interface definitions.
 * @return  The resulting orderHash from hashing the supplied order.
 */
export async function createOrderHashAsync(
  provider: Provider,
  orderLibAddress: string,
  order: Order | SignedOrder
): Promise<string> {
  // below assert statement fails due to issues with BigNumber vs Number.
  // assert.isSchemaValid('Order', order, schemas.OrderSchema);

  const web3: Web3 = new Web3();
  web3.setProvider(provider);

  const orderLib: OrderLib = await OrderLib.createAndValidate(web3, orderLibAddress);

  let orderHash = '';

  await orderLib
    .createOrderHash(
      order.contractAddress,
      // orderAddresses
      [order.maker, order.taker, order.feeRecipient],
      // unsignedOrderValues
      [order.makerFee, order.takerFee, order.price, order.expirationTimestamp, order.salt],
      order.orderQty
    )
    .then(data => (orderHash = data))
    .catch((err: Error) => {
      console.log('Error while creating order hash');
      console.error(err);
    });

  return orderHash;
}

/**
 * Signs an orderHash and returns it's elliptic curve signature.
 * @param   provider        Web3 provider instance.
 * @param   orderHash       Hex encoded orderHash to sign.
 * @param   signerAddress   The hex encoded Ethereum address you wish to sign it with. This address
 *          must be available via the Provider supplied to MARKET.js.
 * @return  An object containing the Elliptic curve signature parameters generated by signing the orderHash.
 */
export async function signOrderHashAsync(
  provider: Provider,
  orderHash: string,
  signerAddress: string
): Promise<ECSignature> {
  const web3: Web3 = new Web3();
  web3.setProvider(provider);
  return Utils.signMessage(web3, signerAddress, orderHash);
}

/**
 * Trades an order and returns success or error.
 * @param   provider        Web3 provider instance.
 * @param   signedOrder     An object that conforms to the SignedOrder interface. The
 *                          signedOrder you wish to validate.
 * @param   fillQty         The amount of the order that you wish to fill.
 * @param   txParams        Transaction params of web3.
 * @return  A boolean indicating whether the order has been successfully traded or not.
 */
export async function tradeOrderAsync(
  provider: Provider,
  signedOrder: SignedOrder,
  fillQty: number,
  txParams: ITxParams = {}
): Promise<boolean> {
  // assert.isSchemaValid('SignedOrder', signedOrder, schemas.SignedOrderSchema);

  const web3: Web3 = new Web3();
  web3.setProvider(provider);

  const marketContract: MarketContract = new MarketContract(web3, signedOrder.contractAddress);

  await marketContract
    .tradeOrderTx(
      // orderAddresses
      [signedOrder.maker, signedOrder.taker, signedOrder.feeRecipient],
      // unsignedOrderValues
      [
        signedOrder.makerFee,
        signedOrder.takerFee,
        signedOrder.price,
        signedOrder.expirationTimestamp,
        signedOrder.salt
      ],
      signedOrder.orderQty,
      fillQty,
      signedOrder.ecSignature.v,
      signedOrder.ecSignature.r,
      signedOrder.ecSignature.s
    )
    .send(txParams);

  return true;
}

/**
 * Confirms a signed order is validly signed
 * @param provider
 * @param orderLibAddress
 * @param signedOrder
 * @param orderHash
 * @return boolean if order hash and signature resolve to maker address (signer)
 */
export async function isValidSignatureAsync(
  provider: Provider,
  orderLibAddress: string,
  signedOrder: SignedOrder,
  orderHash: string
): Promise<boolean> {
  const web3: Web3 = new Web3();
  web3.setProvider(provider);
  const orderLib: OrderLib = await OrderLib.createAndValidate(web3, orderLibAddress);
  return orderLib.isValidSignature(
    signedOrder.maker,
    orderHash,
    signedOrder.ecSignature.v,
    signedOrder.ecSignature.r,
    signedOrder.ecSignature.s
  );
}
